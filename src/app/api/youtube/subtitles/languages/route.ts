import { NextResponse } from 'next/server';
import ytdl from 'ytdl-core';

interface CaptionTrack {
  baseUrl: string;
  languageCode: string;
  name?: {
    simpleText: string;
  };
  kind?: string;
}

export async function GET(request: Request) {
  const { searchParams } = new URL(request.url);
  const videoId = searchParams.get('videoId');

  if (!videoId) {
    return NextResponse.json(
      { error: 'Missing videoId parameter' },
      { status: 400 }
    );
  }

  try {
    // Validate video ID first
    if (!ytdl.validateID(videoId)) {
      return NextResponse.json(
        { error: 'Invalid YouTube video ID' },
        { status: 400 }
      );
    }

    // Get basic video info first
    const basicInfo = await ytdl.getBasicInfo(videoId);
    
    // Get captions data
    const captionsData = basicInfo.player_response.captions;
    if (!captionsData || !captionsData.playerCaptionsTracklistRenderer) {
      // No captions available, return default languages
      return NextResponse.json({
        languages: [
          { code: 'en', name: 'English' },
          { code: 'vi', name: 'Vietnamese' },
          { code: 'fr', name: 'French' },
          { code: 'de', name: 'German' },
          { code: 'ja', name: 'Japanese' },
          { code: 'ko', name: 'Korean' },
          { code: 'es', name: 'Spanish' },
          { code: 'zh', name: 'Chinese' }
        ],
        isDefault: true
      });
    }

    // Extract and process caption tracks
    const captionTracks = (captionsData.playerCaptionsTracklistRenderer.captionTracks || []) as CaptionTrack[];
    
    // Map to our format with additional validation
    const languages = captionTracks
      .filter(track => track && track.languageCode && track.baseUrl) // Ensure valid tracks only
      .map(track => ({
        code: track.languageCode,
        name: track.name?.simpleText || getLanguageName(track.languageCode) || track.languageCode,
        isAutoGenerated: track.kind === 'asr',
        url: track.baseUrl // Store URL for later use
      }));

    if (languages.length === 0) {
      // No valid captions found, return default languages
      return NextResponse.json({
        languages: [
          { code: 'en', name: 'English' },
          { code: 'vi', name: 'Vietnamese' },
          { code: 'fr', name: 'French' },
          { code: 'de', name: 'German' },
          { code: 'ja', name: 'Japanese' },
          { code: 'ko', name: 'Korean' },
          { code: 'es', name: 'Spanish' },
          { code: 'zh', name: 'Chinese' }
        ],
        isDefault: true
      });
    }

    return NextResponse.json({ 
      languages,
      isDefault: false
    });
  } catch (error) {
    console.error('Detailed error:', error);
    
    // Handle specific ytdl-core errors
    if (error instanceof Error) {
      if (error.message.includes('Video unavailable')) {
        return NextResponse.json(
          { error: 'Video is unavailable or private' },
          { status: 404 }
        );
      }
      if (error.message.includes('Status code:')) {
        return NextResponse.json(
          { error: 'YouTube API error: ' + error.message },
          { status: 500 }
        );
      }
    }
    
    return NextResponse.json(
      { error: 'Failed to fetch YouTube captions' },
      { status: 500 }
    );
  }
}

// Helper function to get language names
function getLanguageName(code: string): string {
  const languageNames: { [key: string]: string } = {
    'en': 'English',
    'vi': 'Vietnamese',
    'fr': 'French',
    'de': 'German',
    'ja': 'Japanese',
    'ko': 'Korean',
    'es': 'Spanish',
    'zh': 'Chinese',
    // Add more language codes and names as needed
  };
  return languageNames[code] || code;
} 